# -*- coding:utf-8 -*-import jwtimport datetimeimport hashlibfrom tornado import gen, escape, httpclientfrom datetime import datetime,timedeltafrom Handler import BaseHandler,ApiHTTPErrorfrom auth import jwtauthfrom tornado.escape import json_decode,json_encodefrom sqlalchemy import func, extract, distinctfrom concurrent.futures import ThreadPoolExecutorfrom tornado.concurrent import run_on_executorSECRET = 'my_secret_key''''首页'''# 后台系统登录class AdminLogin(BaseHandler):    """    ================================================        docstring for Login        usertype 默认为0 表示普通用户，1表示为管理员用户    ================================================    """    def _set_token(self):        self.encoded = jwt.encode(            {                "user":                {                    'username': self.username,                    'userid': 1,                    'usertype': 1                },                "exp": datetime.datetime.utcnow() + datetime.timedelta(seconds=60)            },            SECRET,            algorithm='HS256'        )    def post(self):        self.username = self.get_json_argument("username")        self.passwd = self.get_json_argument('password')        passwordmd5 = hashlib.md5()        passwordmd5.update(self.passwd)        inputpasswrod = passwordmd5.hexdigest()        # print self.dbs.user.find({'username': self.username})        passwordmd5.update('admin.jikexueche.com')        if self.username == 'root' and inputpasswrod == passwordmd5.hexdigest():            self._set_token()        response = {'token': self.encoded}        self.write(response)class getFree(BaseHandler):    executor = ThreadPoolExecutor(8)    @gen.coroutine    def get(self, *args, **kwargs):        self.page = int(args[0])        self.limit = int(args[1])        reps  = yield self.getdata()        rep = {}        rep['data'] = {'data':reps[0],'total':reps[1]}        self.writejson(json_decode(str(ApiHTTPError(**rep))))    @run_on_executor    def getdata(self):        start = (self.page-1)*self.limit        total = self.DbRead.query(func.count(self.Student_Demo.sd_id).label('count')).first()        res = self.DbRead.query(self.Student_Demo).offset(start).limit(self.limit)        data = []        for item in res:            dict = {'phone':item.sd_phone,'state':item.sd_state,'createdtime': datetime.strftime(item.sd_createtime,'%Y-%m-%d %H:%I:%S')}            data.append(dict)        self.DbRead.commit()        return data,total.countclass getStudent(BaseHandler):    executor = ThreadPoolExecutor(8)    @gen.coroutine    def get(self, *args, **kwargs):        self.page = int(args[0])        self.limit = int(args[1])        reps  = yield self.getdata()        rep = {}        rep['data'] = {'data':reps[0],'total':reps[1]}        self.writejson(json_decode(str(ApiHTTPError(**rep))))    @run_on_executor    def getdata(self):        start = (self.page-1)*self.limit        total = self.DbRead.query(func.count(self.Student.student_id).label('count')).first()        res = self.DbRead.query(self.Student).offset(start).limit(self.limit)        self.DbRead.commit()        data = []        for item in res:            dict = {'phone':item.student_code,'name':item.student_name,'cardid':item.student_id_number,'createdtime': datetime.strftime(item.student_create_time,'%Y-%m-%d %H:%I:%S')}            data.append(dict)        return data,total.countclass getpackagelist(BaseHandler):    executor = ThreadPoolExecutor(8)    @gen.coroutine    def get(self, *args, **kwargs):        self.page = int(args[0])        self.limit = int(args[1])        reps  = yield self.getdata()        rep = {}        rep['data'] = {'data':reps[0],'total':reps[1]}        self.writejson(json_decode(str(ApiHTTPError(**rep))))    @run_on_executor    def getdata(self):        start = (self.page-1)*self.limit        total = self.DbRead.query(func.count(self.Package.package_id).label('count')).first()        res = self.DbRead.query(self.Student).offset(start).limit(self.limit)        self.DbRead.commit()        data = []        for item in res:            dict = {'phone':item.student_code,'name':item.student_name,'cardid':item.student_id_number,'createdtime': datetime.strftime(item.student_create_time,'%Y-%m-%d %H:%I:%S')}            data.append(dict)        return data,total.count